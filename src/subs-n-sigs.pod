=head0 Subs and Signatures

X<subroutine>
X<arguments>
X<signature>
X<return value>

A I<subroutine> is a piece of code that performs a specific task. It may
operate in provided data, also known as I<arguments>.  It may also produce some
result, which is known as a return value.  The I<signature> of a subroutine is
a description of the arguments it takes and the return value it produces.

You have already seen some simple subroutines in the first chapter.  The second
chapter described operators.  In a sense, these are also subroutines that Perl
6 parses in interesting ways.  However, these just scratch on the surface of
what's possible.

=head1 Declaring A Subroutine

=for author

Is "keyword" the right word?

=end for

Most subroutines have names, which you can use to call them.  The C<sub>
keyword declares a subroutine, followed by a name, a signature, and a block of
code:

=begin programlisting

 sub panic() {
     say "Oh no! Something has gone most terribly wrong!";
 }

 panic();

=end programlisting

X<subroutines; scoping>
X<scoping; subroutines>

By default, subroutines are lexically scoped, just like any variable declared
with C<my>.  In the absence of any code indicating otherwise, you can only call
a subroutine within its given scope.  If you want to sub to be more widely
available, use C<our> to put it in the package.

=begin programlisting

 {
     our sub eat() {
         say "om nom nom";
     }

     sub drink() {
         say "glug glug";
     }
 }

 eat();    # om nom nom
 drink();  # fails, can't drink outside of the block

=end programlisting

X<anonymous subroutines>
X<subroutines; anonymous>
X<subroutines; first-class>
X<first-class subroutines>

Perl 6 subs are objects.  You can pass them around and store them in data
structures just like you can do with any other piece of data.  Programming
language designers often call these I<first-class subroutines>, because they
behave like other built-in data structures.  This offers tremendous potential.
Just like you don't have to name every variable, you don't have to name every
subroutine.  For example, to make a little ASCII art dancing figure, you could
build up a hash where the keys are names of the dance moves, and the values are
anonymous subroutines:

=begin programlisting

 my $dance = '';
 my %moves =
     hands-over-head => sub { $dance ~= '/o\ '   },
     bird-arms       => sub { $dance ~= '|/o\| ' },
     left            => sub { $dance ~= '>o '    },
     right           => sub { $dance ~= 'o< '    },
     arms-up         => sub { $dance ~= '\o/ '   };

 my @awesome-dance = <arms-up bird-arms right hands-over-head>;

 for @awesome-dance -> $move {
     %moves{$move}.();
 }

 say $dance;

=end programlisting

From the output of this program, you can observe that doing the YMCA dance in
ASCII art looks as bad as in real life.

=head1 Adding Signatures
X<parameter>

A sub's signature performs two roles. First, it declares the arguments callers
may or must pass to the subroutine. Second, it declares the variables in the
sub to which to bind those arguments. These variables are called
I<parameters>.  Perl 6 signatures go further; they
allowing you to constrain the values of arguments and to extract specific
pieces of data structures.

=head2 The Basics

In its most simple form, a signature is a comma separated list of variable
names to which to bind incoming arguments.

=begin programlisting

 sub order-beer($type, $pints) {
     say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
 }

 order-beer('Hobgoblin', 1);    # A pint of Hobgoblin, please.
 order-beer('Zlatý Bažant', 3); # 3 pints of Zlatý Bažant, please.

=end programlisting

The use of the term I<bound> instead of I<assigned> is significant. The
variables in your signature are read-only references to the passed arguments.
You cannot modify them within the sub.  If this is too limiting, then you have
two different ways to relax this restriction.

Marking a parameter as C<is rw> means that you are allowed to modify the passed
argument.  If you modify that value, you modify the original in place.  If you
attempt to pass a literal or some other constant value for an C<rw> parameter,
binding of that signature will fail and the subroutine call will not occur.

=begin programlisting

 sub make-it-more-so($it is rw) {
     $it ~= substr($it, $it.chars - 1) x 5;
 }

 my $happy = "yay!";
 make-it-more-so($happy);
 say $happy;                # yay!!!!!!
 make-it-more-so("uh-oh");  # Fails; can't modify a constant

=end programlisting

If instead you want your own copy of the argument to work with inside the
subroutine--if you want to leave the original untouched--then mark the
parameter C<is copy>.

=begin programlisting

 sub say-it-one-higher($it is copy) {
     $it++;
     say $it;
 }

 my $unanswer = 41;
 say-it-one-higher($unanswer);  # 42
 say-it-one-higher(41);         # 42

=end programlisting

The extra verbosity of marking parameters as mutable may seem excessive, but
it's likely you won't use these modifiers often.  While certain languages
require you to mark parameters as C<rw> to emulate returning multiple result
from a single subroutine, Perl allows you to return multiple values directly.

=head2 Passing Arrays, Hashes and Code

Sigils on variables indicate their intended use.  In a signature, a variable
with a sigil acts as a constraint on the type of argument passed.  The C<@>
sigil, for example, checks that the passed value is iterable.  Failing to pass
something that matches this constraint will cause the call to fail.

=begin programlisting

 sub shout-them(@words) {
     for @words -> $w {
         print uc("$w ");
     }
 }

 my @last_words = <do not want>;
 shout-them(@last_words);  # DO NOT WANT
 shout-them('help');       # Fails; a string is not iterable

=end programlisting

Similarly, the C<%> sigil implies that the caller must pass something that
allows associative indexing through the C<< <...> >> or C<{...}> operations.
The C<&> sigil requires that the caller pass something callable, such as an
anonymous subroutine. In that case, you may call the callable parameter without
having to use the C<&> sigil.

=begin programlisting

 sub do-it-lots(&it, $how-many-times) {
     for 1..$how-many-times {
         it();
     }
 }

 do-it-lots(sub { say "Eating a stroopwafel" }, 10);

=end programlisting

A scalar (the C<$> sigil) implies no constraints.  Anything may bind to it,
even if that anything could bind to one of the other sigils.

=head2 Interpolating Arrays and Hashes

Sometimes you want to fill positional arguments from an array. Instead of
writing C<eat(@food[0], @food[1], @food[2], ...)> and so on for every array
item, you can I<interpolate> it into the argument list by prepending a vertical
bar: C<eat(|@food)>.

Likewise you can interpolate hashes into named arguments:

=begin programlisting

 my %user-preferences = from => 'Northern Sea';
 order-shrimps(3, |%user-preferences)

=end programlisting

=head2 Optional Parameters

=for author

Until now, the distinction between "arguments" and "parameters" has been clear.
Here's where it gets confusing.  We should use one consistently, or define the
distinction between the two clearly for readers (if they even need to know a
distinction) and use them precisely.

=end for

Sometimes parameters have sensible defaults values.  Sometimes, certain
arguments are unnecessary.  In these cases, it is nice to mark such parameters
as optional, so those calling the subroutine can choose whether to pass values.

Either assign a default value to the parameter in the signature or append a
question mark to the parameter's name:

=begin programlisting

 # with a default value
 sub order-steak($how = 'medium') {
     say "I'd like a steak, $how";
 }

 order-steak();
 order-steak('well done');

 # without a default value
 # TODO: come up with a good example

=end programlisting

=head2 Named Parameters

When a subroutine has many parameters, it is sometimes hard to remember their
respective order. When that happens, it is often easier to call them by name
instead:

=begin programlisting

 sub order-beer($type, $pints) {
     say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
 }

 order-beer(type => 'Hobgoblin', pints => 1);    # A pint of Hobgoblin, please.
 order-beer(pints => 3, type => 'Zlatý Bažant'); # 3 pints of Zlatý Bažant, please.

=end programlisting

The names are just the ones that appeared as parameter names in the signature.
When arguments are passed by name, the order in which they appear does not
matter anymore.

When a parameter name in a signature is preceded by a colon, then it can only
be filled by name, not by position:

=begin programlisting

 sub order-shrimps($count, :$from = 'North Sea') {
     say "I'd like $count pieces of shrimp from the $from, please";
 }

 order-shrimps(6);                      # takes the default value 'North Sea'
 order-shrimps(4, from => 'Atlantic Ocean');
 order-shrimps(22, 'Mediterranean Sea'); # not allowed, :$from is named only

=end programlisting

Named parameters are optional by default, adding a C<!> at the end makes it
mandatory.

# TODO: example

Just like C<*@rest> slurps up all remaining positional arguments, C<*%rest>
is bound to a hash of all named arguments that have not been bound to an
individual named parameters.

=head3 Renaming Parameters

The name of named parameters is not necessarily tied to the variable name
that is used
inside the subroutine.

=begin programlisting

 sub announce-time(:dinner($supper) = '8pm') {
     say "We eat dinner at $supper";
 }

 announce-time(dinner => '9pm');      # We eat dinner at 9pm

=end programlisting

Parameters can also have multiple names. If the users are both British and
Americans, one might write C<:color(:colour($c))>  or C<:color(:$colour))>.

=head3 Other Syntax for Calling by Name

Just like parameters can be written in the form C<:name($value)>, arguments
can also be supplied with the so-called I<colon pair> notation. So these three
lines mean the same thing:

=begin programlisting

 announce-time(dinner => '9pm');
 announce-time(:dinner('9pm'));
 announce-time(:dinner<9pm>);

=end programlisting

The parens after the name are optional. If they are omitted, the value is
C<Bool::True>. The shorthand for a value of C<Bool::False> is C<:!name>.

Other possible forms and their meanings are listed in the table below.

    Shorthand           Long form                   Description

    :allowed            allowed => Bool::True       Boolean flag
    :!allowed           allowed => Bool::False      Boolean flag
    :bev<tea coffee>    bev => ('tee', 'coffee')    List
    :times[1, 3]        times => [1, 3]             Array
    :hash{ a => 2}      hash => { a => 2}           Hash
    :$var               var => $var                 Scalar variable
    :@var               var => @var                 Array variable
    :%var               var => %var                 Hash variable

All of these forms can also be used in other contexts too, where they
construct C<Pair> objects.

If you want to create a C<Pair> object and pass that to a subroutine not by
name, but by position, you can either put it in parenthesis (like
C<(:$thing)>), or you can use the C<< => >> operator with a quoted string on
the left-hand side: C<< "thing" => $thing >>.

=head2 Slurpy Parameters

In an earlier example the function C<shout-it> accepted an array argument.
There is no need to actually require the user to build an array and pass that
to the function:

=begin programlisting

 sub shout-them(*@words) {
     for @words -> $w {
         print uc("$w ");
     }
 }

 # now you can pass items
 shout-them('go')            # GO
 shout-them('go', 'home');   # GO HOME

 my @words = ('go', 'home');
 shout-them(@words);         # still works

=end programlisting

An asterisk C<*> preceding an array parameter marks it as I<slurpy>. It takes
all remaining positional arguments and stores them in an array.

Likewise C<*%hash> slurps all the remaining named arguments into an array.

With slurpy arrays and hashes you can pass on all positional and named
arguments to another routine:

=begin programlisting

 sub debug-wrapper(&code, *@positional, *%named) {
     warn "Calling '&code.name()' with arguments "
          ~ "@positional.perl(), %named.perl()\n";
     code(|@positional, %named);
     warn "... back from '&code.name()'\n";
 }

 debug-wrapper(&order-shrimps, 4, from => 'Atlantic Ocean');

=end programlisting

=head1 Returning Results

Subroutines can also return values.

The ASCII art examples from earlier would have been prettier if you used
return values instead:

=begin programlisting

 my %moves =
     hands-over-head => sub { return '/o\ '   },
     bird-arms       => sub { return '|/o\| ' },
     left            => sub { return '>o '    },
     right           => sub { return 'o< '    },
     arms-up         => sub { return '\o/ '   };

 my @awesome-dance = <arms-up bird-arms right hands-over-head>;
 for @awesome-dance -> $move {
     print %moves{$move}.();
 }
 print "\n";

=end programlisting

Instead of modifying a variable inside the subroutine, a string is returned,
and used by the code that called the subroutine. Multiple values can also be
returned:

=begin programlisting

 sub menu {
     if rand < 0.5 {
         return ('fish', 'white wine')
     } else {
         return ('steak', 'read wine');
     }
 }

 my ($food, $beverage) = menu();

=end programlisting

The C<return> is actually not necessary - the last statement that is run
inside a subroutine is returned. So the example can be simplified to

=begin programlisting

 sub menu {
     if rand < 0.5 {
         'fish', 'white wine'
     } else {
         'steak', 'read wine';
     }
 }

 my ($food, $beverage) = menu();

=end programlisting

However C<return> has the additional effect of immediately exiting the
subroutine, so the following statements are not executed if the C<return>
statement is run:

# TODO: example

=head1 Working With Types


=head2 Basic Types


=head2 Adding Constraints


=head1 Captures

A signature can be viewed as a collection of parameters. Captures fill the
same niche for arguments. Most of the time, you don't have to think about
captures, just as you don't often think about a signature as a whole but
instead focus more on the parameters in it. However, Perl 6 does provide
you with a way to deal with captures directly, and occasionally it's useful
to do so.

Captures have both a positional part and a named part, which act like a list
and a hash respectively. From the point of view of making a call, the list-like
part contains the positional parameters and the hash-like part contains the
named parameters.

=head2 Creating And Using A Capture


=head2 Captures In Signatures


=head1 Unpacking

Sometimes you don't want to access an array or hash as a whole, but
rather extract some of the values. You could do that with ordinary accesses,
or with signatures by doing another signature binding:

=begin programlisting

  sub first-is-largest(@a) {
      my $first = @a.shift;
      # TODO: either explain junctions, or find a
      # concise way to write without them
      return $first >= all(@a);
  }

  # same thing:
  sub first-is-largest(@a) {
      my :($first, *@rest) ::= \(|@a)
      return $first >= all(@rest);
  }

=end programlisting

The signature binding approach might seem clumsy, but it can be incorporated
into the main signature of the subroutine:

=begin programlisting

  sub first-is-largest([$first, *@rest]) {
      return $first >= all(@rest);
  }

=end programlisting

The brackets in the signature tell the compiler that a list-like argument is
expected, but instead of binding it to an array, it is I<unpacked> into
several
parameters - here a single scalar, and an array containing the rest. This
I<subsignature> also acts as a constraint on the array parameter: the
signature binding will fail unless the list in the capture contains at least
one item.

Likewise a hash can be unpacked by using C<%(...)> instead of the brackets,
and named parameters inside them.

# TODO: come up with a good example

# TODO: generic object unpacking

=head1 Introspection


=for editor vim: se spell
